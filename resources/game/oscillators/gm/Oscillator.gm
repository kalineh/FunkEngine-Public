
global MakeOscillator = function( a_args )
{
    local Oscillator = table();

    Oscillator.threads = table();
    Oscillator.owner = a_args.owner;

    Oscillator.phase = a_args.phase;
    Oscillator.frequency = a_args.frequency;
    Oscillator.amplitude = a_args.amplitude;

    Oscillator.angle = Oscillator.phase;

    Oscillator.pos = a_args.pos;
    Oscillator.radius = a_args.radius;

    Oscillator.Init = function()
    {
        .threads.update = this:thread( .Update );
    };

    Oscillator.Release = function()
    {
        KillThreads( .threads );
    };

    Oscillator.Update = function()
    {
        local average = .owner.GetFieldAverageAngle();
        local convergence = .owner.settings.convergence;

        local collect_deltas = function()
        {
            local delta = 0.0f;
            local convergence = .owner.settings.convergence;
            local normalizer = convergence / tableCount( .owner.oscillators ).Float();

            foreach ( oscillator in .owner.oscillators )
            {
                if ( oscillator == this )
                {
                    continue;
                }

                local diff = AngleDiff( oscillator.angle, .angle );
                
                delta += sin( diff ) * normalizer;
            }

            return delta;
        };

        while ( true )
        {
            local time = .GetAngle();

            //local delta = g_dt * .frequency;
            //local diff = AngleDiff( average, angle );
            //delta += g_dt * sin( diff ) * convergence;

            local delta = g_dt * .frequency + g_dt * this:collect_deltas();

            .angle = .angle + delta;
            .angle = wrap( .angle, -PI, PI );

            yield();
        }
    };

    Oscillator.GetTime = function()
    {
        if ( .owner.global_time )
        {
            return g_game.time + .phase;
        }

        return .angle;
    };

    Oscillator.GetAngle = function()
    {
        local t = .GetTime();
        local s = sin( t ) * PI;

        return s;
    };

    Oscillator.GetV2 = function()
    {
        local t = .GetTime();
        local s = sin( t ) * PI;
        local c = cos( t ) * PI;
        local v = v2( c, s );

        return v * .amplitude;
    };

    Oscillator.Draw = function( a_base_position )
    {
        local hsv = v3( .frequency, 0.5f, 1.0f );
        local rgb = HSVtoRGB( hsv );
        local pos = a_base_position + .pos + .GetV2();
        local radius = .radius;

        Imm.Color( rgb, 1.0f );
        Imm.DrawCircle( pos, radius );
    };

    Oscillator.Init();
    return Oscillator;
};


global MakeOscillatorCircle = function()
{
    local OscillatorCircle = table();

    OscillatorCircle.threads = table(); 
    OscillatorCircle.oscillators = table();

    OscillatorCircle.settings = table();
    OscillatorCircle.settings.count = 32;
    OscillatorCircle.settings.global_time = false;
    OscillatorCircle.settings.convergence = 0.7f;
    OscillatorCircle.settings.dimen_min = 0.0f;
    OscillatorCircle.settings.dimen_max = 0.0f;
    OscillatorCircle.settings.radius_min = 1.0f;
    OscillatorCircle.settings.radius_max = 5.0f;
    OscillatorCircle.settings.phase_min = -PI;
    OscillatorCircle.settings.phase_max = PI;
    OscillatorCircle.settings.frequency_min = 0.0f;
    OscillatorCircle.settings.frequency_max = 2.0f;
    OscillatorCircle.settings.amplitude_min = 32.0f;
    OscillatorCircle.settings.amplitude_max = 48.0f;

    OscillatorCircle.Init = function()
    {
        .Reset();
    };

    OscillatorCircle.Release = function()
    {
        foreach ( oscillator in .oscillators )
        {
            oscillator.Release();
        }

        tableClear( .oscillators );

        KillThreads( .threads );
    };

    OscillatorCircle.Reset = function()
    {
        .Release();

        local count = .settings.count;
        local convergence = .settings.convergence;

        local dimen_min = g_core.screenDimen * .settings.dimen_min;
        local dimen_max = g_core.screenDimen * .settings.dimen_max;
        local radius_min = .settings.radius_min;
        local radius_max = .settings.radius_max;
        local phase_min = .settings.phase_min;
        local phase_max = .settings.phase_max;
        local frequency_min = .settings.frequency_min;
        local frequency_max = .settings.frequency_max;
        local amplitude_min = .settings.amplitude_min;
        local amplitude_max = .settings.amplitude_max;

        local range = function( a_min, a_max )
        {
            // TODO: fix range to be center on 0.5 instead of 0.0

            local x = randfloat( 0.0f, 1.0f );
            local c = gaussian( x, 0.0f, 0.2f );
            local r = a_min + ( a_max - a_min ) * c;

            return r;
        };

        for ( i = 0; i < count; i += 1 )
        {
            local args = {
                owner = this,
                pos = v2( randfloat( dimen_min.x, dimen_max.x ), randfloat( dimen_min.y, dimen_max.y ) ),
                radius = randfloat( radius_min, radius_max ),
                phase = randfloat( phase_min, phase_max ),
                frequency = range( frequency_min, frequency_max ),
                amplitude = range( amplitude_min, amplitude_max ),
            };

            local oscillator = MakeOscillator( args );

            .oscillators[] = oscillator;
        }

        .threads.update = this:thread( .Update );
        .threads.draw = this:thread( .Draw );
        .threads.gui = this:thread( .Gui );
    };

    OscillatorCircle.Update = function()
    {
        while ( true )
        {
            // sum field average
            // - or distance based
            // - or nearest neighbour
            // - or other?

            yield();
        }
    };

    OscillatorCircle.GetFieldAverageV2 = function()
    {
        local average = v2( 0.0f );

        foreach ( oscillator in .oscillators )
        {
            local v = oscillator.GetV2();
            
            average += v;
        }

        average /= tableCount( .oscillators ).Float();

        return average;
    };

    OscillatorCircle.GetFieldAverageAngle = function()
    {
        local average = 0.0f;

        foreach ( oscillator in .oscillators )
        {
            local v = oscillator.GetAngle();
            
            average += v;
        }

        average /= tableCount( .oscillators ).Float();

        return average;
    };

    OscillatorCircle.Draw = function()
    {
        local draw = function()
        {
    		Imm.BeginDefaultShader();
    		Imm.BeginDraw();

            local base_position = g_core.screenDimen * 0.5f;

            foreach ( oscillator in .oscillators )
            {
                oscillator.Draw( base_position );
            }

            local average = .GetFieldAverageV2();

            Imm.Color( Gfx.RED, 1.0f );
            Imm.DrawCircle( base_position + average, 8.0f );

    		Imm.EndDraw();
    		Imm.EndDefaultShader();
        };

        while ( true )
        {
            RegisterDraw( DrawLayers.Scene, draw, this );
            yield();
        }
    };

    OscillatorCircle.Gui = function()
    {
        local gui = function()
        {
    		Gui.Header( "Settings" );

            local previous = tableDuplicate( .settings );

            .settings.count = Gui.SliderInt( "Count", .settings.count, 1, 1024 );
            .settings.global_time = Gui.CheckBox( "Global Time", .settings.global_time );
            .settings.convergence = Gui.SliderFloat( "Convergence", .settings.convergence, 0.0f, 1.0f );
            //.settings.dimen_min = Gui.SliderFloat( "Dimension (min)", .settings.dimen_min, 0.0f, 0.0f );
            //.settings.dimen_max = Gui.SliderFloat( "Dimension (max)", .settings.dimen_max, 0.0f, 0.0f );
            .settings.radius_min = Gui.SliderFloat( "Radius (min)", .settings.radius_min, 1.0f, 32.0f );
            .settings.radius_max = Gui.SliderFloat( "Radius (max)", .settings.radius_max, 1.0f, 32.0f );
            .settings.phase_min = Gui.SliderFloat( "Phase (min)", .settings.phase_min, -PI, PI );
            .settings.phase_max = Gui.SliderFloat( "Phase (max)", .settings.phase_max, -PI, PI );
            .settings.frequency_min = Gui.SliderFloat( "Frequency (min)", .settings.frequency_min, 0.0f, 4.0f );
            .settings.frequency_max = Gui.SliderFloat( "Frequency (max)", .settings.frequency_max, 0.0f, 4.0f );
            .settings.amplitude_min = Gui.SliderFloat( "Amplitude (min)", .settings.amplitude_min, 0.0f, 128.0f );
            .settings.amplitude_max = Gui.SliderFloat( "Amplitude (max)", .settings.amplitude_max, 0.0f, 128.0f );

            foreach ( key and value in previous )
            {
                if ( value != .settings[ key ] )
                {
                    .Reset();

                    break;
                }
            }

            local average_v2 = .GetFieldAverageV2();
            local average_angle = .GetFieldAverageAngle();

            Gui.Print( format( "average: %f (%f,%f)", average_angle, average_v2.x, average_v2.y ) );

            // TODO: shuffle

            if ( Gui.Button( "Reset" ) )
            {
                .Reset();
            }
        };

        while ( true )
        {
			RegisterGui( "OscillatorCircle", gui, this );

            yield();
        }
    };

    OscillatorCircle.Init();
    return OscillatorCircle;
};
